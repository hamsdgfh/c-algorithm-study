
---

## 2) ÏõåÌÅ¨ÌîåÎ°ú(`.github/workflows/auto-readme.yml`) ÏóÖÍ∑∏Î†àÏù¥Îìú

> Í∏∞Ï°¥ ÌååÏùºÏùÑ ÏïÑÎûòÎ°ú **ÌÜµÏß∏Î°ú ÍµêÏ≤¥**ÌïòÏÑ∏Ïöî.  
> (SWEA + ‚ÄúÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏‚Äù ÏûêÎèô ÏÑπÏÖò + Ï†ëÍ∏∞/ÌïÑÌÑ∞Îäî README Ï™ΩÏóêÏÑú Ï≤òÎ¶¨Îê©ÎãàÎã§)

```yaml
name: Auto update README index (grouped raw/clean + recent)

on:
  push:
    branches: [ "main" ]    # Í∏∞Î≥∏ Î∏åÎûúÏπòÎ™ÖÏù¥ Îã§Î•¥Î©¥ ÏàòÏ†ïÌïòÏÑ∏Ïöî (Ïòà: master)
    paths:
      - "baekjoon/**"
      - "programmers/**"
      - "swea/**"
      - ".github/workflows/auto-readme.yml"
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    env:
      LANG: C.UTF-8
      LC_ALL: C.UTF-8

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate grouped index
        shell: bash
        run: |
          set -euo pipefail

          echo "[DEBUG] Listing directories for BOJ/PGS/SWEA..."
          find baekjoon    -maxdepth 3 -print 2>/dev/null || true
          find programmers -maxdepth 3 -print 2>/dev/null || true
          find swea        -maxdepth 3 -print 2>/dev/null || true

          link_if() {
            # $1 = path, $2 = label
            if [ -f "$1" ]; then
              printf '[%s](%s)' "$2" "$1"
            fi
          }

          list_grouped_boj() {
            [ -d baekjoon ] || return 0
            echo "## Baekjoon"
            local found=0
            # Ìè¥ÎçîÌòï: baekjoon/<Tier>/<Î¨∏Ï†úÌè¥Îçî>/{raw.c,clean.c,note.md}
            while IFS= read -r d; do
              tier="$(echo "$d" | awk -F/ '{print $2}')"
              prob="$(basename "$d")"
              local raw_link clean_link note_link out dot
              raw_link="$(link_if "$d/raw.c" raw || true)"
              clean_link="$(link_if "$d/clean.c" clean || true)"
              note_link="$(link_if "$d/note.md" note || true)"
              out=""; dot=""
              [ -n "$raw_link" ]  && { out="$raw_link";           dot=" ‚Ä¢ "; }
              [ -n "$clean_link" ]&& { out="${out}${dot}$clean_link"; dot=" ‚Ä¢ "; }
              [ -n "$note_link" ] && { out="${out}${dot}$note_link"; }
              pretty_tier="$(echo "$tier" | sed 's/_/ /g')" # Bronze_III -> Bronze III
              printf -- "- **[%s](%s)** _(Tier: %s)_ ‚Äî %s\n" "$prob" "$d" "$pretty_tier" "${out:-ÏóÜÏùå}"
              found=1
            done < <(find baekjoon -type d -mindepth 2 -maxdepth 2 | sort)

            # Îã®Ïùº ÌååÏùºÌòïÎèÑ ÏßÄÏõê: baekjoon/<Tier>/*.c
            while IFS= read -r f; do
              tier="$(echo "$f" | awk -F/ '{print $2}')"
              pretty_tier="$(echo "$tier" | sed 's/_/ /g')"
              name="$(basename "$f")"
              printf -- "- [%s](%s) _(Tier: %s)_\n" "$name" "$f" "$pretty_tier"
              found=1
            done < <(find baekjoon -type f -mindepth 2 -maxdepth 2 -name '*.c' | sort)

            [ "$found" -eq 1 ] || echo "- (ÏïÑÏßÅ ÏóÜÏùå)"
            echo
          }

          list_grouped_pgs() {
            [ -d programmers ] || return 0
            echo "## Programmers"
            local found=0
            while IFS= read -r d; do
              level="$(echo "$d" | awk -F/ '{print $2}')"
              title="$(basename "$d")"
              local raw_link clean_link note_link out dot
              raw_link="$(link_if "$d/raw.c" raw || true)"
              clean_link="$(link_if "$d/clean.c" clean || true)"
              note_link="$(link_if "$d/note.md" note || true)"
              out=""; dot=""
              [ -n "$raw_link" ]  && { out="$raw_link";           dot=" ‚Ä¢ "; }
              [ -n "$clean_link" ]&& { out="${out}${dot}$clean_link"; dot=" ‚Ä¢ "; }
              [ -n "$note_link" ] && { out="${out}${dot}$note_link"; }
              pretty_level="$(echo "$level" | sed 's/Level//')"
              printf -- "- **[%s](%s)** _(Level: %s)_ ‚Äî %s\n" "$title" "$d" "$pretty_level" "${out:-ÏóÜÏùå}"
              found=1
            done < <(find programmers -type d -mindepth 2 -maxdepth 2 | sort)

            while IFS= read -r f; do
              level="$(echo "$f" | awk -F/ '{print $2}')"
              pretty_level="$(echo "$level" | sed 's/Level//')"
              name="$(basename "$f")"
              printf -- "- [%s](%s) _(Level: %s)_\n" "$name" "$f" "$pretty_level"
              found=1
            done < <(find programmers -type f -mindepth 2 -maxdepth 2 -name '*.c' | sort)

            [ "$found" -eq 1 ] || echo "- (ÏïÑÏßÅ ÏóÜÏùå)"
            echo
          }

          list_grouped_swea() {
            [ -d swea ] || return 0
            echo "## SW Expert Academy"
            local found=0
            # Í∂åÏû•: swea/D3/<Î¨∏Ï†úÌè¥Îçî>/{raw.c,clean.c,note.md}
            while IFS= read -r d; do
              level="$(echo "$d" | awk -F/ '{print $2}')"  # D1/D2/...
              title="$(basename "$d")"
              local raw_link clean_link note_link out dot
              raw_link="$(link_if "$d/raw.c" raw || true)"
              clean_link="$(link_if "$d/clean.c" clean || true)"
              note_link="$(link_if "$d/note.md" note || true)"
              out=""; dot=""
              [ -n "$raw_link" ]  && { out="$raw_link";           dot=" ‚Ä¢ "; }
              [ -n "$clean_link" ]&& { out="${out}${dot}$clean_link"; dot=" ‚Ä¢ "; }
              [ -n "$note_link" ] && { out="${out}${dot}$note_link"; }
              printf -- "- **[%s](%s)** _(Level: %s)_ ‚Äî %s\n" "$title" "$d" "$level" "${out:-ÏóÜÏùå}"
              found=1
            done < <(find swea -type d -mindepth 2 -maxdepth 2 | sort)

            while IFS= read -r f; do
              level="$(echo "$f" | awk -F/ '{print $2}')"
              name="$(basename "$f")"
              printf -- "- [%s](%s) _(Level: %s)_\n" "$name" "$f" "$level"
              found=1
            done < <(find swea -type f -mindepth 2 -maxdepth 2 -name '*.c' | sort)

            [ "$found" -eq 1 ] || echo "- (ÏïÑÏßÅ ÏóÜÏùå)"
            echo
          }

          {
            list_grouped_boj
            list_grouped_pgs
            list_grouped_swea
          } > _AUTO_INDEX.md

          echo "=== _AUTO_INDEX.md ==="
          cat _AUTO_INDEX.md

      - name: Generate recent commits (last 10)
        shell: bash
        run: |
          set -euo pipefail
          REPO_URL="${GITHUB_SERVER_URL:-https://github.com}/${GITHUB_REPOSITORY}"
          # baekjoon/programmers/swea ÌïòÏúÑ Î≥ÄÍ≤ΩÎßå ÏßëÍ≥Ñ
          git log --date=short --pretty=format:'- %ad ¬∑ %s ([%h]('"$REPO_URL"'/commit/%H))' -n 10 -- baekjoon programmers swea > _RECENT.md || true
          if [ ! -s _RECENT.md ]; then
            echo "- (ÏµúÍ∑º Î≥ÄÍ≤Ω ÏóÜÏùå)" > _RECENT.md
          fi
          echo "=== _RECENT.md ==="
          cat _RECENT.md

      - name: Update README between markers
        shell: bash
        run: |
          set -euo pipefail

          START="<!-- AUTO-INDEX:START -->"
          END="<!-- AUTO-INDEX:END -->"
          RSTART="<!-- RECENT:START -->"
          REND="<!-- RECENT:END -->"

          # README ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Í≥®Í≤© ÏÉùÏÑ±
          if [ ! -f README.md ]; then
            printf "%s\n" "# C Algorithm Study" > README.md
            printf "\n" >> README.md
            printf "%s\n" "## üÜï ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏ (ÏûêÎèô)" >> README.md
            printf "%s\n" "$RSTART" >> README.md
            printf "%s\n" "- (ÏµúÍ∑º Î≥ÄÍ≤Ω ÏóÜÏùå)" >> README.md
            printf "%s\n" "$REND" >> README.md
            printf "\n" >> README.md
            printf "%s\n" "## üóÇÔ∏è Î¨∏Ï†ú Î™©Î°ù (ÏûêÎèô ÏÉùÏÑ±)" >> README.md
            printf "%s\n" "$START" >> README.md
            printf "%s\n" "_ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§. Î¨∏Ï†ú Ìè¥ÎçîÎßå Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî._" >> README.md
            printf "%s\n" "$END" >> README.md
          fi

          # ÎßàÏª§ ÌôïÏù∏
          grep -q "$START" README.md
          grep -q "$END" README.md
          grep -q "$RSTART" README.md
          grep -q "$REND" README.md

          # ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏ ÏπòÌôò
          awk -v s="$RSTART" -v e="$REND" 'BEGIN{p=1}
            $0 ~ s {print; system("cat _RECENT.md"); p=0; next}
            $0 ~ e {p=1}
            p {print}
          ' README.md > README.tmp && mv README.tmp README.md

          # Î¨∏Ï†ú Ïù∏Îç±Ïä§ ÏπòÌôò
          awk -v s="$START" -v e="$END" 'BEGIN{p=1}
            $0 ~ s {print; system("cat _AUTO_INDEX.md"); p=0; next}
            $0 ~ e {p=1}
            p {print}
          ' README.md > README.new

          mv README.new README.md
          rm -f _AUTO_INDEX.md _RECENT.md

      - name: Commit & push if changed
        shell: bash
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No changes in README."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "docs(readme): auto-update grouped index & recent commits"
          git push
