name: Auto update README index (grouped raw/clean + recent)

on:
  push:
    branches: [ "main" ]
    paths:
      - "baekjoon/**"
      - "programmers/**"
      - "swea/**"
      - ".github/workflows/auto-readme.yml"
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    env:
      LANG: C.UTF-8
      LC_ALL: C.UTF-8

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate grouped index (collapsible by tier/level)
        shell: bash
        run: |
          set -euo pipefail

          echo "[DEBUG] Listing directories..."
          find baekjoon    -maxdepth 4 -print 2>/dev/null || true
          find programmers -maxdepth 4 -print 2>/dev/null || true
          find swea        -maxdepth 4 -print 2>/dev/null || true

          link_if() {
            # $1 = path, $2 = label
            if [ -f "$1" ]; then
              printf '[%s](%s)' "$2" "$1"
            fi
          }

          # í™•ì¥ì ì§‘í•©(í•„ìš”ì‹œ ì¶”ê°€/ì‚­ì œ)
          EXTS='\( -name "*.c" -o -name "*.cpp" -o -name "*.cc" -o -name "*.py" -o -name "*.java" -o -name "*.js" -o -name "*.ts" -o -name "*.kt" -o -name "*.rs" -o -name "*.go" \)'

          list_grouped_boj() {
            [ -d baekjoon ] || return 0
            echo "## Baekjoon"
            local any=0

            # ê³ ìœ  í‹°ì–´ ëª©ë¡
            mapfile -t TIERS < <(find baekjoon -type d -mindepth 2 -maxdepth 3 -printf '%P\n' 2>/dev/null | awk -F/ 'NF>=2{print $1}' | sort -u)
            # ë‹¨ì¼ íŒŒì¼ì´ì§€ë§Œ tier í´ë” ë°”ë¡œ ì•„ë˜ì— ìˆëŠ” ê²½ìš°ë„ ì¹´ìš´íŠ¸
            mapfile -t TIERS2 < <(find baekjoon -type f -mindepth 1 -maxdepth 3 2>/dev/null | awk -F/ 'NF>=2{print $2}' | sort -u)
            TIERS=($(printf "%s\n" "${TIERS[@]}" "${TIERS2[@]}" | sed '/^$/d' | sort -u))

            if [ "${#TIERS[@]}" -eq 0 ]; then
              echo "- (ì•„ì§ ì—†ìŒ)"
              echo
              return 0
            fi

            for tier in "${TIERS[@]}"; do
              pretty_tier="$(echo "$tier" | sed 's/_/ /g')"

              # í•­ëª© ìˆ˜ ì§‘ê³„
              count=$(
                { find "baekjoon/$tier" -type d -mindepth 1 -maxdepth 2 2>/dev/null; \
                  eval find "baekjoon/$tier" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null; } \
                | wc -l | tr -d ' '
              )

              echo "<details><summary><strong>${pretty_tier}</strong> <sub>(${count})</sub></summary>"
              echo

              # í´ë”í˜•: baekjoon/<Tier>/<ë¬¸ì œ> or <Tier>/<ë¶„ë¥˜>/<ë¬¸ì œ>
              while IFS= read -r d; do
                [ -z "$d" ] && continue
                prob="$(basename "$d")"
                raw_link="$(link_if "$d/raw.c" raw || true)"
                clean_link="$(link_if "$d/clean.c" clean || true)"
                note_link="$(link_if "$d/note.md" note || true)"
                out=""; dot=""
                [ -n "$raw_link" ]   && { out="$raw_link";              dot=" â€¢ "; }
                [ -n "$clean_link" ] && { out="${out}${dot}$clean_link"; dot=" â€¢ "; }
                [ -n "$note_link" ]  && { out="${out}${dot}$note_link"; }
                printf -- "- **[%s](%s)** â€” %s\n" "$prob" "$d" "${out:-ì—†ìŒ}"
                any=1
              done < <(find "baekjoon/$tier" -type d -mindepth 1 -maxdepth 2 2>/dev/null | sort)

              # ë‹¨ì¼ íŒŒì¼í˜•: baekjoon/<Tier>/*.{c,cpp,py,...}
              while IFS= read -r f; do
                [ -z "$f" ] && continue
                name="$(basename "$f")"
                printf -- "- [%s](%s)\n" "$name" "$f"
                any=1
              done < <(eval find "baekjoon/$tier" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null | sort)

              echo
              echo "</details>"
              echo
            done

            [ "$any" -eq 1 ] || echo "- (ì•„ì§ ì—†ìŒ)"
            echo
          }

          list_grouped_pgs() {
            [ -d programmers ] || return 0
            echo "## Programmers"
            local any=0

            mapfile -t LEVELS < <(find programmers -type d -mindepth 2 -maxdepth 3 -printf '%P\n' 2>/dev/null | awk -F/ 'NF>=2{print $1}' | sort -u)
            mapfile -t LEVELS2 < <(find programmers -type f -mindepth 1 -maxdepth 3 2>/dev/null | awk -F/ 'NF>=2{print $2}' | sort -u)
            LEVELS=($(printf "%s\n" "${LEVELS[@]}" "${LEVELS2[@]}" | sed '/^$/d' | sort -u))

            if [ "${#LEVELS[@]}" -eq 0 ]; then
              echo "- (ì•„ì§ ì—†ìŒ)"
              echo
              return 0
            fi

            for level in "${LEVELS[@]}"; do
              pretty_level="$(echo "$level" | sed -e 's/Level//I')"
              count=$(
                { find "programmers/$level" -type d -mindepth 1 -maxdepth 2 2>/dev/null; \
                  eval find "programmers/$level" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null; } \
                | wc -l | tr -d ' '
              )

              echo "<details><summary><strong>Level ${pretty_level}</strong> <sub>(${count})</sub></summary>"
              echo

              while IFS= read -r d; do
                [ -z "$d" ] && continue
                title="$(basename "$d")"
                raw_link="$(link_if "$d/raw.c" raw || true)"
                clean_link="$(link_if "$d/clean.c" clean || true)"
                note_link="$(link_if "$d/note.md" note || true)"
                out=""; dot=""
                [ -n "$raw_link" ]   && { out="$raw_link";              dot=" â€¢ "; }
                [ -n "$clean_link" ] && { out="${out}${dot}$clean_link"; dot=" â€¢ "; }
                [ -n "$note_link" ]  && { out="${out}${dot}$note_link"; }
                printf -- "- **[%s](%s)** â€” %s\n" "$title" "$d" "${out:-ì—†ìŒ}"
                any=1
              done < <(find "programmers/$level" -type d -mindepth 1 -maxdepth 2 2>/dev/null | sort)

              while IFS= read -r f; do
                [ -z "$f" ] && continue
                name="$(basename "$f")"
                printf -- "- [%s](%s)\n" "$name" "$f"
                any=1
              done < <(eval find "programmers/$level" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null | sort)

              echo
              echo "</details>"
              echo
            done

            [ "$any" -eq 1 ] || echo "- (ì•„ì§ ì—†ìŒ)"
            echo
          }

          list_grouped_swea() {
            [ -d swea ] || return 0
            echo "## SW Expert Academy"
            local any=0

            mapfile -t LVLS < <(find swea -type d -mindepth 2 -maxdepth 3 -printf '%P\n' 2>/dev/null | awk -F/ 'NF>=2{print $1}' | sort -u)
            mapfile -t LVLS2 < <(find swea -type f -mindepth 1 -maxdepth 3 2>/dev/null | awk -F/ 'NF>=2{print $2}' | sort -u)
            LVLS=($(printf "%s\n" "${LVLS[@]}" "${LVLS2[@]}" | sed '/^$/d' | sort -u))

            if [ "${#LVLS[@]}" -eq 0 ]; then
              echo "- (ì•„ì§ ì—†ìŒ)"
              echo
              return 0
            fi

            for L in "${LVLS[@]}"; do
              count=$(
                { find "swea/$L" -type d -mindepth 1 -maxdepth 2 2>/dev/null; \
                  eval find "swea/$L" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null; } \
                | wc -l | tr -d ' '
              )

              echo "<details><summary><strong>${L}</strong> <sub>(${count})</sub></summary>"
              echo

              while IFS= read -r d; do
                [ -z "$d" ] && continue
                title="$(basename "$d")"
                raw_link="$(link_if "$d/raw.c" raw || true)"
                clean_link="$(link_if "$d/clean.c" clean || true)"
                note_link="$(link_if "$d/note.md" note || true)"
                out=""; dot=""
                [ -n "$raw_link" ]   && { out="$raw_link";              dot=" â€¢ "; }
                [ -n "$clean_link" ] && { out="${out}${dot}$clean_link"; dot=" â€¢ "; }
                [ -n "$note_link" ]  && { out="${out}${dot}$note_link"; }
                printf -- "- **[%s](%s)** â€” %s\n" "$title" "$d" "${out:-ì—†ìŒ}"
                any=1
              done < <(find "swea/$L" -type d -mindepth 1 -maxdepth 2 2>/dev/null | sort)

              while IFS= read -r f; do
                [ -z "$f" ] && continue
                name="$(basename "$f")"
                printf -- "- [%s](%s)\n" "$name" "$f"
                any=1
              done < <(eval find "swea/$L" -type f -mindepth 0 -maxdepth 2 $EXTS 2>/dev/null | sort)

              echo
              echo "</details>"
              echo
            done

            [ "$any" -eq 1 ] || echo "- (ì•„ì§ ì—†ìŒ)"
            echo
          }

          {
            list_grouped_boj
            list_grouped_pgs
            list_grouped_swea
          } > _AUTO_INDEX.md

          echo "=== _AUTO_INDEX.md (preview) ==="
          sed -n '1,120p' _AUTO_INDEX.md || true

      - name: Generate recent commits (last 10)
        shell: bash
        run: |
          set -euo pipefail
          REPO_URL="${GITHUB_SERVER_URL:-https://github.com}/${GITHUB_REPOSITORY}"
          git log --date=short --pretty=format:'- %ad Â· %s ([%h]('"$REPO_URL"'/commit/%H))' -n 10 -- baekjoon programmers swea > _RECENT.md || true
          if [ ! -s _RECENT.md ]; then
            echo "- (ìµœê·¼ ë³€ê²½ ì—†ìŒ)" > _RECENT.md
          fi
          echo "=== _RECENT.md ==="
          cat _RECENT.md

      - name: Update README between markers (robust + quick filters header)
        shell: bash
        run: |
          set -euo pipefail

          START="<!-- AUTO-INDEX:START -->"
          END="<!-- AUTO-INDEX:END -->"
          RSTART="<!-- RECENT:START -->"
          REND="<!-- RECENT:END -->"

          : > _AUTO_INDEX.md
          : > _RECENT.md

          REPO_URL="${GITHUB_SERVER_URL:-https://github.com}/${GITHUB_REPOSITORY}"

          # README ì—†ìœ¼ë©´ ê¸°ë³¸ ê³¨ê²© + ìƒë‹¨ ìœ í‹¸ ì„¹ì…˜ ìƒì„±
          if [ ! -f README.md ]; then
            {
              printf "%s\n" "# C Algorithm Study"
              printf "\n"
              printf "%s\n" "### ğŸ” Quick Filters & âŒ¨ï¸ Shortcuts"
              printf "%s\n" "- **ê²€ìƒ‰ ë‹¨ì¶•í‚¤**: \`/\` ê²€ìƒ‰ í¬ì»¤ìŠ¤, \`t\` íŒŒì¼ íƒìƒ‰ê¸°, \`g\`â†’\`i\` ì´ìŠˆë¡œ ì´ë™"
              printf "%s\n" "- **ì–¸ì–´ë³„ ë¹ ë¥¸ ê²€ìƒ‰**: [C](%s/search?q=extension%%3Ac+path%%3Abaekjoon+OR+path%%3Aprogrammers+OR+path%%3Aswea) Â· [C++](%s/search?q=extension%%3Acpp) Â· [Python](%s/search?q=extension%%3Apy) Â· [Java](%s/search?q=extension%%3Ajava)" "$REPO_URL" "$REPO_URL" "$REPO_URL" "$REPO_URL"
              printf "%s\n" "- **í´ë”ë³„ ë¹ ë¥¸ ê²€ìƒ‰**: [Baekjoon](%s/search?q=path%%3Abaekjoon) Â· [Programmers](%s/search?q=path%%3Aprogrammers) Â· [SWEA](%s/search?q=path%%3Aswea)" "$REPO_URL" "$REPO_URL" "$REPO_URL"
              printf "\n"
              printf "%s\n" "## ğŸ†• ìµœê·¼ ì—…ë°ì´íŠ¸ (ìë™)"
              printf "%s\n" "$RSTART"
              printf "%s\n" "- (ìµœê·¼ ë³€ê²½ ì—†ìŒ)"
              printf "%s\n" "$REND"
              printf "\n"
              printf "%s\n" "## ğŸ—‚ï¸ ë¬¸ì œ ëª©ë¡ (ìë™ ìƒì„±)"
              printf "%s\n" "$START"
              printf "%s\n" "_ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤. í‹°ì–´/ë ˆë²¨ë³„ ì ‘ê¸° ì§€ì›_"
              printf "%s\n" "$END"
            } > README.md
          fi

          # ìƒë‹¨ Quick Filters & Shortcuts ë¸”ë¡ ë³´ì¥ (ì—†ìœ¼ë©´ ì‚½ì…)
          if ! grep -q "Quick Filters & .*Shortcuts" README.md; then
            tmp_head="$(mktemp)"
            {
              printf "%s\n" "### ğŸ” Quick Filters & âŒ¨ï¸ Shortcuts"
              printf "%s\n" "- **ê²€ìƒ‰ ë‹¨ì¶•í‚¤**: \`/\` ê²€ìƒ‰ í¬ì»¤ìŠ¤, \`t\` íŒŒì¼ íƒìƒ‰ê¸°, \`g\`â†’\`i\` ì´ìŠˆë¡œ ì´ë™"
              printf "%s\n" "- **ì–¸ì–´ë³„ ë¹ ë¥¸ ê²€ìƒ‰**: [C](%s/search?q=extension%%3Ac+path%%3Abaekjoon+OR+path%%3Aprogrammers+OR+path%%3Aswea) Â· [C++](%s/search?q=extension%%3Acpp) Â· [Python](%s/search?q=extension%%3Apy) Â· [Java](%s/search?q=extension%%3Ajava)" "$REPO_URL" "$REPO_URL" "$REPO_URL" "$REPO_URL"
              printf "%s\n" "- **í´ë”ë³„ ë¹ ë¥¸ ê²€ìƒ‰**: [Baekjoon](%s/search?q=path%%3Abaekjoon) Â· [Programmers](%s/search?q=path%%3Aprogrammers) Â· [SWEA](%s/search?q=path%%3Aswea)" "$REPO_URL" "$REPO_URL" "$REPO_URL"
              printf "\n"
            } > "$tmp_head"
            # ì œëª© ë°”ë¡œ ì•„ë˜ì— ì‚½ì…
            awk -v ins="$(sed 's/[&/\]/\\&/g' "$tmp_head")" '
              NR==1{print;next}
              NR==2{print ins}
              {print}
            ' README.md > README.tmp && mv README.tmp README.md
            rm -f "$tmp_head"
          fi

          # === ë§ˆì»¤ ë³´ì • ===
          if ! grep -qF "$RSTART" README.md; then
            printf "\n## ğŸ†• ìµœê·¼ ì—…ë°ì´íŠ¸ (ìë™)\n%s\n- (ìµœê·¼ ë³€ê²½ ì—†ìŒ)\n%s\n" "$RSTART" "$REND" >> README.md
          fi
          if ! grep -qF "$REND" README.md; then
            echo "$REND" >> README.md
          fi
          if ! grep -qF "$START" README.md; then
            printf "\n## ğŸ—‚ï¸ ë¬¸ì œ ëª©ë¡ (ìë™ ìƒì„±)\n%s\n_ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤. í‹°ì–´/ë ˆë²¨ë³„ ì ‘ê¸° ì§€ì›_\n%s\n" "$START" "$END" >> README.md
          fi
          if ! grep -qF "$END" README.md; then
            echo "$END" >> README.md
          fi

          # === ìµœê·¼ ì—…ë°ì´íŠ¸ ì¹˜í™˜ ===
          awk -v s="$RSTART" -v e="$REND" '
            BEGIN{p=1}
            $0 ~ s { print; system("cat _RECENT.md"); p=0; next }
            $0 ~ e { p=1 }
            p { print }
          ' README.md > README.tmp && mv README.tmp README.md

          # === ì¸ë±ìŠ¤ ì¹˜í™˜(ì ‘í˜ ì„¹ì…˜ í¬í•¨) ===
          awk -v s="$START" -v e="$END" '
            BEGIN{p=1}
            $0 ~ s { print; system("cat _AUTO_INDEX.md"); p=0; next }
            $0 ~ e { p=1 }
            p { print }
          ' README.md > README.new && mv README.new README.md

          rm -f _AUTO_INDEX.md _RECENT.md

      - name: Commit & push if changed
        shell: bash
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No changes in README."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "docs(readme): auto-index with collapsible sections + quick filters + recent commits"
          git push
